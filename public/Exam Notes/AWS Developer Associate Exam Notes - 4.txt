What is CI/CD
  - Continuous Integration
    - Code changes trigger an automated build
    - build runs automated tests
  - Continuous Delivery/Deployment
    - Continuous Delivery
      - continuous delivery is a deployment practice where merged changes are automatically built, tested, and prepared for release into staging and eventually production environments
      - there is usually a manual decision process to initiate deployment of the new code
    - Continuous Deployment
      - automatically deploys the new code following successful testing, eliminating any manual steps
      - the new code is automatically released as soon as it passes the stages of your release process (build, test, package)
      - continuous deployment also automates the release process
  - CodeCommit is the code repository
  - CodeBuild is the build management system
  - CodeDeploy is the deployment system
  - CodePipeline coordinates the CI/CD pipeline
  - Continuous Integration is about integrating or merging code changes frequently
  - Continuous Delivery is about automating the build, test, deploy functions (usually requires human intervention)
  - Continuous Deployment fully automates the entire release process
CodeCommit 101
  - fully managed source control service that enables companies to host secure and highly scalable private git repositories
  - centralized repository for all your code, binaries, images, and libraries
  - tracks and manages code changes
  - maintains version history
  - manages updates from multiple sources
  - enables collaboration
  - users create a branch of the master repository which they can update independently
  - saved changes which are ready to be applied to the repository are known as commits
  - when the branch code is ready to be added to the master repository, the branch is merged into the master
  - provides all the capabilities of git
  - data is encrypted in transit and at rest
    - connect to CodeCommit via https or ssh
CodeDeploy 101
  - automated deployment service which allows you to deploy your application code automatically to EC2 instances, on-premise systems, and lambda functions
  - ensures that all deployments are consistent because it removes all manual steps
  - automatically scales with your infrastructure and integrates with various CI-CD tools (Jenkins, GitHub, Atlassian, AWS CodePipeline) as well as config management tools like Ansible, Puppet, and Chef
  - two deployment approaches available:
    - In-place
      - the application is stopped on each instance and the latest revision is installed
      - the instance is out of service during this time and your capacity will be reduced
      - if the instances are behind a load balancer, you can configure the load balancer to stop sending requests to the instances which are being upgraded
      - in-place is also known as a rolling update
      - can only be used for EC2 and on-premise systems, it is not supported for lambda
      - if you need to rollback your changes, the previous version of the application will need to be redeployed
    - Blue-green
      - new instances are provisioned and the latest revision is installed on the new instances
      - blue represents the active deployment, green is the new release
      - the new instances are registered with the elastic load balancer, traffic is then routed to the new instances and the original instances are eventually terminated
      - advantage: the new instances can be created ahead of time and the code released to production by simply switching all traffic to the new servers
      - switching back to the original environment is faster and more reliable and is just a case of routing the traffic back to the original servers
      - no reduction in performance or capacity during the deployment
  - code deploy terminology
    - deployment group
      - a set of EC2 instances or lambda functions to which a new revision of the software is to be deployed
    - deployment
      - the process and components used to apply a new revision
    - deployment configuration
      - a set of deployment rules as well as success-failure conditions used during deployment
    - AppSpec file
      - defines the deployment actions you want AWS CodeDeploy to execute
    - revision
      - everything needed to deploy the new version (AppSpec file, application files, executables, config files)
    - application
      - unique identifier for the application you want to deploy to ensure the correct combination of revision, deployment configuration, and deployment group are referenced during deployment
  - uses a CodeDeploy agent on EC2 instances
CodePipeline 101
  - a fully managed continuous integration and continuous delivery service
  - can orchestrate the build, test, and even deployment of your application every time there is a change to your code, based on a user defined software release process
  - allows you to model your release process as a workflow or pipeline made up of different tasks
  - you define what happens and where for each of the different stages of the workflow, and this can be modeled using the CodePipeline GUI or CLI
  - integrates with CodeCommit, CodeBuild, CodeDeploy, lambda, Elastic Beanstalk, CloudFormation, ECS, as well as third party tools such as GitHub and Jenkins
  - every code change pushed to your code repository automatically enters the workflow and triggers the set of actions defined for each stage of the pipeline
  - the pipeline automatically stops if one of the stages fails, such as a unit test failure, and the change is rolled back
Advanced CodeDeploy and the AppSpec File
  - AppSepc file is used to define parameters that will be used for a CodeDeploy deployment
  - file structure depends on whether you are deploying to lambda or EC2-On Premise
  - for lambda deployments, the AppSpec file may be written in YAMML or JSON
    - contains the following fields
      - version
        - reserver for future use, currently the only allowed value is 0.0
      - resources
        - the name and properties of the lambda function to deploy
      - hooks
        - specifies lambda functions to run at set points in the deployment lifecycle to validate the deployment such as validation tests to run before allowing traffic to be sent to your newly deployed lambda instances
          - two hooks available when using AppSpec with lambda
            - BeforeAllowTraffic
              - used to specify the tasks or functions you want to run before traffic is routed to the newly deployed lambda function such as test to validate that the function has been deployed correctly
            - AfterAllowTraffic
              - used to specify the tasks or functions you want to run after the traffic has been routed to the newly deployed lambda function such as test to validate that the function is accepting traffic correctly and is behaving as expected
  - for EC2 and On-premise deployments
    - must be written in YAML
    - contains the following fields
      - version
        - reserved for future use, currently the only allowed value is 0.0
      - os
        - the operating system version you are using
      - files
        - the location of any application files that need to be copied and where they should be copied (source and destination folders)
      - hooks
        - lifecycle event hooks allow you to specify scripts that need to be run at set points in the deployment lifecycle such as unzip application files prior to deployment, run functional tests on the newly deployed application, de-register and re-register instances with a load balancer
          - run order of hooks when using AppSpec with EC2 and On-premise
            - 1 first these
              - BeforeBlockTraffic
                - run tasks on instances before they are deregistered from a load balancer
              - BlockTraffic
                - deregister instances from a load balancer
              - AfterBlockTraffic
                - run tasks on instances after they are deregistered from a load balancer
            - 2 then these
              - ApplicationStop
                - gracefully stop the application in preparation for deploying the new version
              - DownloadBundle
                - the CodeDeploy agent copies the application version files to a temporary location
              - BeforeInstall
                - details of any pre-installation scripts, such as backing up the current version, or decrypting files
              - Install
                - the CodeDeploy agent copies the application revision files from their temporary location to their correct location
              - AfterInstall
                - details of any post-installation scripts, such as configuration tasks, change file permissions
              - ApplicationStart
                - restarts any services that were stopped during ApplicationStop
              - ValidateService
                 - details of any tests to validate the service
            - 3 last these
              - BeforeAllowTraffic
                - run tasks on instances before they are registered with a load balancer
              - AllowTraffic
                - register instances with a load balancer
              - AfterAllowTraffic
                - run tasks on instances after they are registered with a load balancer
    - the appspec.yml file must be placed in the root directory of your revision (the directory containing your application source code) otherwise the deployment will fail
Docker and CodeBuild
  - ECS is a fully managed clustered platform which allows you to run your own Docker images in the cloud
  - Docker commands to build, tag (apply an alias), and push your Docker image to the ECR repository
    - docker build -t myimagerepo
    - docker tag myimagerepo:latest 725654345.dkr.ecr.region-name.amazonaws.com/myimagerepo:latest
    - docker push 725654345.dkr.ecr.region-name.amazonaws.com/myimagerepo:latest
  - use buildspec.yml to define the build commands and settings used by CodeBuild to run your build
  - you can override the settings in the buildspec.yml by adding your own commands in the console when you launch the build
  - if your build fails, check the build logs in the CodeBuild console and you can also view the full CodeBuild log in CloudWatch
CloudFormation
  - a service that allows you to manage, configure and provision your AWS infrastructure as code
  - resources are defined using a CloudFormation template
  - CloudFormation interprets the template and makes the appropriate API calls to create the resources you have defined
  - support YAML and JSON
  - infrastructure is provisioned consistently, with fewer mistakes
  - less time and effort than configuring manually
  - can version control and peer review templates
  - free to use (charged for what you create)
  - can be used to manage updates and dependencies
  - can be used to roll back and delete the entire stack
  - YAML or JSON template used to describe the end-state of the infrastructure you are provisioning or changing
  - after creating the template, you upload it to CloudFormation using S3
  - CloudFormation reads the template and makes the API calls on your behalf
  - the resulting resources are called a stack
  - Resources is the only mandatory section of the CloudFormation template
  - the Transform section is used to reference additional code stored in S3, allowing for code reuse such as a lambda function or template snippets
  - the main sections of a CloudFormation template:
    - Parameters
      - input custom values into the stack
    - Conditions
      - provision resources based on environment
    - Resources
      - mandatory, the AWS resources to create
    - Mappings
      - create custom mappings like Region to AMI
    - Transforms
      - reference code located in S3, such as lambda functions, or reusable snippets of CloudFormation code
Serverless Application Model (SAM)
  - an extension to CloudFormation used to define serverless applications
  - simplified syntax for defining serverless resources, APIs, lambda functions, DynamoDB tables
  - use the SAM CLI to package your deployment code, upload it to S3 and deploy your serverless application
  - SAM CLI commands used to package and deploy
    - sam package
      - packages your application and uploads to S3
    - sam deploy
      - deploys your serverless application using CloudFormation
  - the Transform:AWS::Serverless-2016-10-31 line of the template tells CloudFormation that the template will create a SAM template
CloudFormation Nested Stacks
  - allow reuse of CloudFormation code for common use cases
    - standard configuration for
      - load balancer
      - web server
      - application server
  - create a standard template for each common use case, store them in S3, and reference from within your CloudFormation template using the Stack resource type
Developer Theory Summary
  - read the white paper:
    - https://d0.awsstatic.com/whitepapers/DevOps/practicing-continuous-integration-continuous-delivery-on-AWS.pdf
Dev Theory Quiz (START HERE)
  -  
